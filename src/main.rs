mod symbols;
mod profiling;
mod intervals;

use std::{borrow::Cow, fs::File, io::Read, time::Instant};
use clap::{Arg, App};

use symbols::*;
use profiling::*;
use intervals::*;

fn main() -> Result<(), Cow<'static, str>> {
    let matches = App::new("md-profiler")
        .version(env!("CARGO_PKG_VERSION"))
        .author("Tails8521 <tails8521@gmail.com>")
        .about("A Sega MegaDrive/Genesis profiler")
        .usage("md-profiler [-m <MANUAL INTERVALS>] [-s <SYMBOLS>] -i <INPUT> -o <OUTPUT>\nor\n    md-profiler -m <MANUAL INTERVALS> [-s <SYMBOLS>] -b <BREAKPOINTS OUTPUT FILE>")
        .arg(Arg::with_name("MANUAL INTERVALS")
            .short("m")
            .long("manual-intervals")
            .takes_value(true)
            .help("Manual intervals text file, allows you to record the time elapsed between two labels in the program"))
        .arg(Arg::with_name("SYMBOLS")
            .short("s")
            .long("symbols")
            .takes_value(true)
            .help("Symbol file, not stricly required, but strongly recommended to make sense of the trace"))
        .arg(Arg::with_name("INPUT")
            .short("i")
            .long("input")
            .takes_value(true)
            .help("Input mdp file generated by BlastEm"))
        .arg(Arg::with_name("OUTPUT")
            .short("o")
            .long("output")
            .takes_value(true)
            .help("Output json file"))
        .arg(Arg::with_name("BREAKPOINTS OUTPUT FILE")
            .short("b")
            .long("breakpoints-output")
            .takes_value(true)
            .help("Output breakpoint file for BlastEm"))
        .get_matches();


    match (matches.value_of("MANUAL INTERVALS"), matches.value_of("SYMBOLS"), matches.value_of("INPUT"), matches.value_of("OUTPUT"), matches.value_of("BREAKPOINTS OUTPUT FILE"),) {
        (interval_file, symbol_file, Some(input), Some(output), None) => {
            let symbols = if let Some(symbol_file) = symbol_file {
                let mut symbol_data = Vec::new();
                let instant = Instant::now();
                File::open(symbol_file).expect("Couldn't open symbol file").read_to_end(&mut symbol_data).expect("Error reading symbol file");
                let symbols = read_symbols(&symbol_data);
                let elapsed = instant.elapsed();
                println!("Parsed {} symbols in {} ms", symbols.label_to_address.len(), elapsed.as_micros() as f64 / 1000.0);
                symbols
            } else {
                Default::default()
            };
            let (mut intervals, custom_threads) = if let Some(interval_file) = interval_file {
                let mut interval_data = Vec::new();
                File::open(interval_file).expect("Couldn't open symbol file").read_to_end(&mut interval_data).expect("Error reading symbol file");
                read_intervals(&interval_data, &symbols.label_to_address)
            } else {
                Default::default()
            };
        
            let mut profiling_data = Vec::new();
            let instant = Instant::now();
            File::open(input).expect("Couldn't open input file").read_to_end(&mut profiling_data).expect("Error reading input file");
            let profiling = read_profiling_file(&profiling_data);
            let elapsed = instant.elapsed();
            println!("Parsed {} input events in {} ms", profiling.packets.len(), elapsed.as_micros() as f64 / 1000.0);
            let mut profile_json = File::create(output).expect("Couldn't create output file");
            generate_profiling_json(&mut profile_json, &profiling, &symbols, &mut intervals, custom_threads);
            Ok(())
        },
        (_interval_file, _symbol_file, Some(_input), None, _breakpoints_output) => {
            Err("Missing --output (-o)".into())
        },
        (_interval_file, _symbol_file, None, Some(_output), _breakpoints_output) => {
            Err("Missing --input (-i)".into())
        },
        (_interval_file, _symbol_file, Some(_input), Some(_output), Some(_breakpoints_output)) => {
            Err("--breakpoints-output (-b) cannot be used with --intput (-i) and --output (-o)".into())
        },
        (Some(interval_file), symbol_file, None, None, Some(breakpoints_output)) => {
            let symbols = if let Some(symbol_file) = symbol_file {
                let mut symbol_data = Vec::new();
                let instant = Instant::now();
                File::open(symbol_file).expect("Couldn't open symbol file").read_to_end(&mut symbol_data).expect("Error reading symbol file");
                let symbols = read_symbols(&symbol_data);
                let elapsed = instant.elapsed();
                println!("Parsed {} symbols in {} ms", symbols.label_to_address.len(), elapsed.as_micros() as f64 / 1000.0);
                symbols
            } else {
                Default::default()
            };
            let mut interval_data = Vec::new();
            File::open(interval_file).expect("Couldn't open symbol file").read_to_end(&mut interval_data).expect("Error reading symbol file");
            let (intervals, _custom_threads) = read_intervals(&interval_data, &symbols.label_to_address);
            let mut breakpoint_file = File::create(breakpoints_output).expect("Couldn't create output file");
            intervals.write_to_file(&mut breakpoint_file);
            println!("Wrote breakpoint addresses to {}", breakpoints_output);
            Ok(())
        },
        (None, _symbol_file, _input, _output, Some(_breakpoints_output)) => {
            Err("--breakpoints-output (-b) requires --manual-intervals (-m)".into())
        },
        _ => {
            eprintln!("{}", matches.usage());
            Ok(())
        }
    }
}
